// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_2eproto;
namespace robot {
class ControlSignalRequest;
struct ControlSignalRequestDefaultTypeInternal;
extern ControlSignalRequestDefaultTypeInternal _ControlSignalRequest_default_instance_;
class ControlSignalResponse;
struct ControlSignalResponseDefaultTypeInternal;
extern ControlSignalResponseDefaultTypeInternal _ControlSignalResponse_default_instance_;
class RecorderConfigActual;
struct RecorderConfigActualDefaultTypeInternal;
extern RecorderConfigActualDefaultTypeInternal _RecorderConfigActual_default_instance_;
class RecorderGetStateReply;
struct RecorderGetStateReplyDefaultTypeInternal;
extern RecorderGetStateReplyDefaultTypeInternal _RecorderGetStateReply_default_instance_;
class RecorderGetStateRequest;
struct RecorderGetStateRequestDefaultTypeInternal;
extern RecorderGetStateRequestDefaultTypeInternal _RecorderGetStateRequest_default_instance_;
class RecorderReinitPerCameraResult;
struct RecorderReinitPerCameraResultDefaultTypeInternal;
extern RecorderReinitPerCameraResultDefaultTypeInternal _RecorderReinitPerCameraResult_default_instance_;
class RecorderReinitReply;
struct RecorderReinitReplyDefaultTypeInternal;
extern RecorderReinitReplyDefaultTypeInternal _RecorderReinitReply_default_instance_;
class RecorderReinitRequest;
struct RecorderReinitRequestDefaultTypeInternal;
extern RecorderReinitRequestDefaultTypeInternal _RecorderReinitRequest_default_instance_;
class RecorderReinitTarget;
struct RecorderReinitTargetDefaultTypeInternal;
extern RecorderReinitTargetDefaultTypeInternal _RecorderReinitTarget_default_instance_;
class RsRecorderTarget;
struct RsRecorderTargetDefaultTypeInternal;
extern RsRecorderTargetDefaultTypeInternal _RsRecorderTarget_default_instance_;
class RsStreamSpec;
struct RsStreamSpecDefaultTypeInternal;
extern RsStreamSpecDefaultTypeInternal _RsStreamSpec_default_instance_;
class V4L2RecorderTarget;
struct V4L2RecorderTargetDefaultTypeInternal;
extern V4L2RecorderTargetDefaultTypeInternal _V4L2RecorderTarget_default_instance_;
class V4L2StreamSpec;
struct V4L2StreamSpecDefaultTypeInternal;
extern V4L2StreamSpecDefaultTypeInternal _V4L2StreamSpec_default_instance_;
}  // namespace robot
PROTOBUF_NAMESPACE_OPEN
template<> ::robot::ControlSignalRequest* Arena::CreateMaybeMessage<::robot::ControlSignalRequest>(Arena*);
template<> ::robot::ControlSignalResponse* Arena::CreateMaybeMessage<::robot::ControlSignalResponse>(Arena*);
template<> ::robot::RecorderConfigActual* Arena::CreateMaybeMessage<::robot::RecorderConfigActual>(Arena*);
template<> ::robot::RecorderGetStateReply* Arena::CreateMaybeMessage<::robot::RecorderGetStateReply>(Arena*);
template<> ::robot::RecorderGetStateRequest* Arena::CreateMaybeMessage<::robot::RecorderGetStateRequest>(Arena*);
template<> ::robot::RecorderReinitPerCameraResult* Arena::CreateMaybeMessage<::robot::RecorderReinitPerCameraResult>(Arena*);
template<> ::robot::RecorderReinitReply* Arena::CreateMaybeMessage<::robot::RecorderReinitReply>(Arena*);
template<> ::robot::RecorderReinitRequest* Arena::CreateMaybeMessage<::robot::RecorderReinitRequest>(Arena*);
template<> ::robot::RecorderReinitTarget* Arena::CreateMaybeMessage<::robot::RecorderReinitTarget>(Arena*);
template<> ::robot::RsRecorderTarget* Arena::CreateMaybeMessage<::robot::RsRecorderTarget>(Arena*);
template<> ::robot::RsStreamSpec* Arena::CreateMaybeMessage<::robot::RsStreamSpec>(Arena*);
template<> ::robot::V4L2RecorderTarget* Arena::CreateMaybeMessage<::robot::V4L2RecorderTarget>(Arena*);
template<> ::robot::V4L2StreamSpec* Arena::CreateMaybeMessage<::robot::V4L2StreamSpec>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace robot {

enum ControlSignalRequest_ActionType : int {
  ControlSignalRequest_ActionType_UNKNOWN = 0,
  ControlSignalRequest_ActionType_CONNECT = 1,
  ControlSignalRequest_ActionType_DISCONNECT = 2,
  ControlSignalRequest_ActionType_ControlSignalRequest_ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ControlSignalRequest_ActionType_ControlSignalRequest_ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ControlSignalRequest_ActionType_IsValid(int value);
constexpr ControlSignalRequest_ActionType ControlSignalRequest_ActionType_ActionType_MIN = ControlSignalRequest_ActionType_UNKNOWN;
constexpr ControlSignalRequest_ActionType ControlSignalRequest_ActionType_ActionType_MAX = ControlSignalRequest_ActionType_DISCONNECT;
constexpr int ControlSignalRequest_ActionType_ActionType_ARRAYSIZE = ControlSignalRequest_ActionType_ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControlSignalRequest_ActionType_descriptor();
template<typename T>
inline const std::string& ControlSignalRequest_ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControlSignalRequest_ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControlSignalRequest_ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControlSignalRequest_ActionType_descriptor(), enum_t_value);
}
inline bool ControlSignalRequest_ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ControlSignalRequest_ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControlSignalRequest_ActionType>(
    ControlSignalRequest_ActionType_descriptor(), name, value);
}
// ===================================================================

class ControlSignalRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.ControlSignalRequest) */ {
 public:
  inline ControlSignalRequest() : ControlSignalRequest(nullptr) {}
  ~ControlSignalRequest() override;
  explicit PROTOBUF_CONSTEXPR ControlSignalRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlSignalRequest(const ControlSignalRequest& from);
  ControlSignalRequest(ControlSignalRequest&& from) noexcept
    : ControlSignalRequest() {
    *this = ::std::move(from);
  }

  inline ControlSignalRequest& operator=(const ControlSignalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlSignalRequest& operator=(ControlSignalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlSignalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlSignalRequest* internal_default_instance() {
    return reinterpret_cast<const ControlSignalRequest*>(
               &_ControlSignalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ControlSignalRequest& a, ControlSignalRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlSignalRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlSignalRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlSignalRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlSignalRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlSignalRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlSignalRequest& from) {
    ControlSignalRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlSignalRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.ControlSignalRequest";
  }
  protected:
  explicit ControlSignalRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ControlSignalRequest_ActionType ActionType;
  static constexpr ActionType UNKNOWN =
    ControlSignalRequest_ActionType_UNKNOWN;
  static constexpr ActionType CONNECT =
    ControlSignalRequest_ActionType_CONNECT;
  static constexpr ActionType DISCONNECT =
    ControlSignalRequest_ActionType_DISCONNECT;
  static inline bool ActionType_IsValid(int value) {
    return ControlSignalRequest_ActionType_IsValid(value);
  }
  static constexpr ActionType ActionType_MIN =
    ControlSignalRequest_ActionType_ActionType_MIN;
  static constexpr ActionType ActionType_MAX =
    ControlSignalRequest_ActionType_ActionType_MAX;
  static constexpr int ActionType_ARRAYSIZE =
    ControlSignalRequest_ActionType_ActionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ActionType_descriptor() {
    return ControlSignalRequest_ActionType_descriptor();
  }
  template<typename T>
  static inline const std::string& ActionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ActionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ActionType_Name.");
    return ControlSignalRequest_ActionType_Name(enum_t_value);
  }
  static inline bool ActionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ActionType* value) {
    return ControlSignalRequest_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSdpTypeFieldNumber = 2,
    kSdpFieldNumber = 3,
    kActionFieldNumber = 1,
  };
  // string sdp_type = 2;
  void clear_sdp_type();
  const std::string& sdp_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp_type();
  PROTOBUF_NODISCARD std::string* release_sdp_type();
  void set_allocated_sdp_type(std::string* sdp_type);
  private:
  const std::string& _internal_sdp_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp_type(const std::string& value);
  std::string* _internal_mutable_sdp_type();
  public:

  // string sdp = 3;
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // .robot.ControlSignalRequest.ActionType action = 1;
  void clear_action();
  ::robot::ControlSignalRequest_ActionType action() const;
  void set_action(::robot::ControlSignalRequest_ActionType value);
  private:
  ::robot::ControlSignalRequest_ActionType _internal_action() const;
  void _internal_set_action(::robot::ControlSignalRequest_ActionType value);
  public:

  // @@protoc_insertion_point(class_scope:robot.ControlSignalRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class ControlSignalResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.ControlSignalResponse) */ {
 public:
  inline ControlSignalResponse() : ControlSignalResponse(nullptr) {}
  ~ControlSignalResponse() override;
  explicit PROTOBUF_CONSTEXPR ControlSignalResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlSignalResponse(const ControlSignalResponse& from);
  ControlSignalResponse(ControlSignalResponse&& from) noexcept
    : ControlSignalResponse() {
    *this = ::std::move(from);
  }

  inline ControlSignalResponse& operator=(const ControlSignalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlSignalResponse& operator=(ControlSignalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlSignalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlSignalResponse* internal_default_instance() {
    return reinterpret_cast<const ControlSignalResponse*>(
               &_ControlSignalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ControlSignalResponse& a, ControlSignalResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlSignalResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlSignalResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ControlSignalResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ControlSignalResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlSignalResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ControlSignalResponse& from) {
    ControlSignalResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlSignalResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.ControlSignalResponse";
  }
  protected:
  explicit ControlSignalResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kSdpTypeFieldNumber = 2,
    kSdpFieldNumber = 3,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string sdp_type = 2;
  void clear_sdp_type();
  const std::string& sdp_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp_type();
  PROTOBUF_NODISCARD std::string* release_sdp_type();
  void set_allocated_sdp_type(std::string* sdp_type);
  private:
  const std::string& _internal_sdp_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp_type(const std::string& value);
  std::string* _internal_mutable_sdp_type();
  public:

  // string sdp = 3;
  void clear_sdp();
  const std::string& sdp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp();
  PROTOBUF_NODISCARD std::string* release_sdp();
  void set_allocated_sdp(std::string* sdp);
  private:
  const std::string& _internal_sdp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp(const std::string& value);
  std::string* _internal_mutable_sdp();
  public:

  // @@protoc_insertion_point(class_scope:robot.ControlSignalResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RsStreamSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RsStreamSpec) */ {
 public:
  inline RsStreamSpec() : RsStreamSpec(nullptr) {}
  ~RsStreamSpec() override;
  explicit PROTOBUF_CONSTEXPR RsStreamSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RsStreamSpec(const RsStreamSpec& from);
  RsStreamSpec(RsStreamSpec&& from) noexcept
    : RsStreamSpec() {
    *this = ::std::move(from);
  }

  inline RsStreamSpec& operator=(const RsStreamSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline RsStreamSpec& operator=(RsStreamSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RsStreamSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const RsStreamSpec* internal_default_instance() {
    return reinterpret_cast<const RsStreamSpec*>(
               &_RsStreamSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RsStreamSpec& a, RsStreamSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(RsStreamSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RsStreamSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RsStreamSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RsStreamSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RsStreamSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RsStreamSpec& from) {
    RsStreamSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RsStreamSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RsStreamSpec";
  }
  protected:
  explicit RsStreamSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kFmtFieldNumber = 5,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kFpsFieldNumber = 4,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string fmt = 5;
  void clear_fmt();
  const std::string& fmt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fmt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fmt();
  PROTOBUF_NODISCARD std::string* release_fmt();
  void set_allocated_fmt(std::string* fmt);
  private:
  const std::string& _internal_fmt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fmt(const std::string& value);
  std::string* _internal_mutable_fmt();
  public:

  // uint32 width = 2;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 3;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // uint32 fps = 4;
  void clear_fps();
  uint32_t fps() const;
  void set_fps(uint32_t value);
  private:
  uint32_t _internal_fps() const;
  void _internal_set_fps(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:robot.RsStreamSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fmt_;
    uint32_t width_;
    uint32_t height_;
    uint32_t fps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RsRecorderTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RsRecorderTarget) */ {
 public:
  inline RsRecorderTarget() : RsRecorderTarget(nullptr) {}
  ~RsRecorderTarget() override;
  explicit PROTOBUF_CONSTEXPR RsRecorderTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RsRecorderTarget(const RsRecorderTarget& from);
  RsRecorderTarget(RsRecorderTarget&& from) noexcept
    : RsRecorderTarget() {
    *this = ::std::move(from);
  }

  inline RsRecorderTarget& operator=(const RsRecorderTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline RsRecorderTarget& operator=(RsRecorderTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RsRecorderTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const RsRecorderTarget* internal_default_instance() {
    return reinterpret_cast<const RsRecorderTarget*>(
               &_RsRecorderTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RsRecorderTarget& a, RsRecorderTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(RsRecorderTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RsRecorderTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RsRecorderTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RsRecorderTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RsRecorderTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RsRecorderTarget& from) {
    RsRecorderTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RsRecorderTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RsRecorderTarget";
  }
  protected:
  explicit RsRecorderTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamsFieldNumber = 2,
    kCameraNameFieldNumber = 1,
  };
  // repeated .robot.RsStreamSpec streams = 2;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  ::robot::RsStreamSpec* mutable_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RsStreamSpec >*
      mutable_streams();
  private:
  const ::robot::RsStreamSpec& _internal_streams(int index) const;
  ::robot::RsStreamSpec* _internal_add_streams();
  public:
  const ::robot::RsStreamSpec& streams(int index) const;
  ::robot::RsStreamSpec* add_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RsStreamSpec >&
      streams() const;

  // string camera_name = 1;
  void clear_camera_name();
  const std::string& camera_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* camera_name);
  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(const std::string& value);
  std::string* _internal_mutable_camera_name();
  public:

  // @@protoc_insertion_point(class_scope:robot.RsRecorderTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RsStreamSpec > streams_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class V4L2StreamSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.V4L2StreamSpec) */ {
 public:
  inline V4L2StreamSpec() : V4L2StreamSpec(nullptr) {}
  ~V4L2StreamSpec() override;
  explicit PROTOBUF_CONSTEXPR V4L2StreamSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V4L2StreamSpec(const V4L2StreamSpec& from);
  V4L2StreamSpec(V4L2StreamSpec&& from) noexcept
    : V4L2StreamSpec() {
    *this = ::std::move(from);
  }

  inline V4L2StreamSpec& operator=(const V4L2StreamSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline V4L2StreamSpec& operator=(V4L2StreamSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const V4L2StreamSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const V4L2StreamSpec* internal_default_instance() {
    return reinterpret_cast<const V4L2StreamSpec*>(
               &_V4L2StreamSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(V4L2StreamSpec& a, V4L2StreamSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(V4L2StreamSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V4L2StreamSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V4L2StreamSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V4L2StreamSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const V4L2StreamSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const V4L2StreamSpec& from) {
    V4L2StreamSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(V4L2StreamSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.V4L2StreamSpec";
  }
  protected:
  explicit V4L2StreamSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixelFormatFourccFieldNumber = 4,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kFpsFieldNumber = 3,
  };
  // string pixel_format_fourcc = 4;
  void clear_pixel_format_fourcc();
  const std::string& pixel_format_fourcc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pixel_format_fourcc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pixel_format_fourcc();
  PROTOBUF_NODISCARD std::string* release_pixel_format_fourcc();
  void set_allocated_pixel_format_fourcc(std::string* pixel_format_fourcc);
  private:
  const std::string& _internal_pixel_format_fourcc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pixel_format_fourcc(const std::string& value);
  std::string* _internal_mutable_pixel_format_fourcc();
  public:

  // uint32 width = 1;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 2;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // uint32 fps = 3;
  void clear_fps();
  uint32_t fps() const;
  void set_fps(uint32_t value);
  private:
  uint32_t _internal_fps() const;
  void _internal_set_fps(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:robot.V4L2StreamSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pixel_format_fourcc_;
    uint32_t width_;
    uint32_t height_;
    uint32_t fps_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class V4L2RecorderTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.V4L2RecorderTarget) */ {
 public:
  inline V4L2RecorderTarget() : V4L2RecorderTarget(nullptr) {}
  ~V4L2RecorderTarget() override;
  explicit PROTOBUF_CONSTEXPR V4L2RecorderTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  V4L2RecorderTarget(const V4L2RecorderTarget& from);
  V4L2RecorderTarget(V4L2RecorderTarget&& from) noexcept
    : V4L2RecorderTarget() {
    *this = ::std::move(from);
  }

  inline V4L2RecorderTarget& operator=(const V4L2RecorderTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline V4L2RecorderTarget& operator=(V4L2RecorderTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const V4L2RecorderTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const V4L2RecorderTarget* internal_default_instance() {
    return reinterpret_cast<const V4L2RecorderTarget*>(
               &_V4L2RecorderTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(V4L2RecorderTarget& a, V4L2RecorderTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(V4L2RecorderTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(V4L2RecorderTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  V4L2RecorderTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<V4L2RecorderTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const V4L2RecorderTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const V4L2RecorderTarget& from) {
    V4L2RecorderTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(V4L2RecorderTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.V4L2RecorderTarget";
  }
  protected:
  explicit V4L2RecorderTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraNameFieldNumber = 1,
    kStreamFieldNumber = 2,
  };
  // string camera_name = 1;
  void clear_camera_name();
  const std::string& camera_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* camera_name);
  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(const std::string& value);
  std::string* _internal_mutable_camera_name();
  public:

  // .robot.V4L2StreamSpec stream = 2;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::robot::V4L2StreamSpec& stream() const;
  PROTOBUF_NODISCARD ::robot::V4L2StreamSpec* release_stream();
  ::robot::V4L2StreamSpec* mutable_stream();
  void set_allocated_stream(::robot::V4L2StreamSpec* stream);
  private:
  const ::robot::V4L2StreamSpec& _internal_stream() const;
  ::robot::V4L2StreamSpec* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::robot::V4L2StreamSpec* stream);
  ::robot::V4L2StreamSpec* unsafe_arena_release_stream();

  // @@protoc_insertion_point(class_scope:robot.V4L2RecorderTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    ::robot::V4L2StreamSpec* stream_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RecorderReinitTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RecorderReinitTarget) */ {
 public:
  inline RecorderReinitTarget() : RecorderReinitTarget(nullptr) {}
  ~RecorderReinitTarget() override;
  explicit PROTOBUF_CONSTEXPR RecorderReinitTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecorderReinitTarget(const RecorderReinitTarget& from);
  RecorderReinitTarget(RecorderReinitTarget&& from) noexcept
    : RecorderReinitTarget() {
    *this = ::std::move(from);
  }

  inline RecorderReinitTarget& operator=(const RecorderReinitTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecorderReinitTarget& operator=(RecorderReinitTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecorderReinitTarget& default_instance() {
    return *internal_default_instance();
  }
  enum DetailCase {
    kRs = 1,
    kV4L2 = 2,
    DETAIL_NOT_SET = 0,
  };

  static inline const RecorderReinitTarget* internal_default_instance() {
    return reinterpret_cast<const RecorderReinitTarget*>(
               &_RecorderReinitTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RecorderReinitTarget& a, RecorderReinitTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(RecorderReinitTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecorderReinitTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecorderReinitTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecorderReinitTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecorderReinitTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecorderReinitTarget& from) {
    RecorderReinitTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecorderReinitTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RecorderReinitTarget";
  }
  protected:
  explicit RecorderReinitTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRsFieldNumber = 1,
    kV4L2FieldNumber = 2,
  };
  // .robot.RsRecorderTarget rs = 1;
  bool has_rs() const;
  private:
  bool _internal_has_rs() const;
  public:
  void clear_rs();
  const ::robot::RsRecorderTarget& rs() const;
  PROTOBUF_NODISCARD ::robot::RsRecorderTarget* release_rs();
  ::robot::RsRecorderTarget* mutable_rs();
  void set_allocated_rs(::robot::RsRecorderTarget* rs);
  private:
  const ::robot::RsRecorderTarget& _internal_rs() const;
  ::robot::RsRecorderTarget* _internal_mutable_rs();
  public:
  void unsafe_arena_set_allocated_rs(
      ::robot::RsRecorderTarget* rs);
  ::robot::RsRecorderTarget* unsafe_arena_release_rs();

  // .robot.V4L2RecorderTarget v4l2 = 2;
  bool has_v4l2() const;
  private:
  bool _internal_has_v4l2() const;
  public:
  void clear_v4l2();
  const ::robot::V4L2RecorderTarget& v4l2() const;
  PROTOBUF_NODISCARD ::robot::V4L2RecorderTarget* release_v4l2();
  ::robot::V4L2RecorderTarget* mutable_v4l2();
  void set_allocated_v4l2(::robot::V4L2RecorderTarget* v4l2);
  private:
  const ::robot::V4L2RecorderTarget& _internal_v4l2() const;
  ::robot::V4L2RecorderTarget* _internal_mutable_v4l2();
  public:
  void unsafe_arena_set_allocated_v4l2(
      ::robot::V4L2RecorderTarget* v4l2);
  ::robot::V4L2RecorderTarget* unsafe_arena_release_v4l2();

  void clear_detail();
  DetailCase detail_case() const;
  // @@protoc_insertion_point(class_scope:robot.RecorderReinitTarget)
 private:
  class _Internal;
  void set_has_rs();
  void set_has_v4l2();

  inline bool has_detail() const;
  inline void clear_has_detail();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DetailUnion {
      constexpr DetailUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::robot::RsRecorderTarget* rs_;
      ::robot::V4L2RecorderTarget* v4l2_;
    } detail_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RecorderReinitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RecorderReinitRequest) */ {
 public:
  inline RecorderReinitRequest() : RecorderReinitRequest(nullptr) {}
  ~RecorderReinitRequest() override;
  explicit PROTOBUF_CONSTEXPR RecorderReinitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecorderReinitRequest(const RecorderReinitRequest& from);
  RecorderReinitRequest(RecorderReinitRequest&& from) noexcept
    : RecorderReinitRequest() {
    *this = ::std::move(from);
  }

  inline RecorderReinitRequest& operator=(const RecorderReinitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecorderReinitRequest& operator=(RecorderReinitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecorderReinitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecorderReinitRequest* internal_default_instance() {
    return reinterpret_cast<const RecorderReinitRequest*>(
               &_RecorderReinitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RecorderReinitRequest& a, RecorderReinitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecorderReinitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecorderReinitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecorderReinitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecorderReinitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecorderReinitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecorderReinitRequest& from) {
    RecorderReinitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecorderReinitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RecorderReinitRequest";
  }
  protected:
  explicit RecorderReinitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 1,
  };
  // repeated .robot.RecorderReinitTarget targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::robot::RecorderReinitTarget* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitTarget >*
      mutable_targets();
  private:
  const ::robot::RecorderReinitTarget& _internal_targets(int index) const;
  ::robot::RecorderReinitTarget* _internal_add_targets();
  public:
  const ::robot::RecorderReinitTarget& targets(int index) const;
  ::robot::RecorderReinitTarget* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitTarget >&
      targets() const;

  // @@protoc_insertion_point(class_scope:robot.RecorderReinitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitTarget > targets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RecorderReinitPerCameraResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RecorderReinitPerCameraResult) */ {
 public:
  inline RecorderReinitPerCameraResult() : RecorderReinitPerCameraResult(nullptr) {}
  ~RecorderReinitPerCameraResult() override;
  explicit PROTOBUF_CONSTEXPR RecorderReinitPerCameraResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecorderReinitPerCameraResult(const RecorderReinitPerCameraResult& from);
  RecorderReinitPerCameraResult(RecorderReinitPerCameraResult&& from) noexcept
    : RecorderReinitPerCameraResult() {
    *this = ::std::move(from);
  }

  inline RecorderReinitPerCameraResult& operator=(const RecorderReinitPerCameraResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecorderReinitPerCameraResult& operator=(RecorderReinitPerCameraResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecorderReinitPerCameraResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecorderReinitPerCameraResult* internal_default_instance() {
    return reinterpret_cast<const RecorderReinitPerCameraResult*>(
               &_RecorderReinitPerCameraResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RecorderReinitPerCameraResult& a, RecorderReinitPerCameraResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RecorderReinitPerCameraResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecorderReinitPerCameraResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecorderReinitPerCameraResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecorderReinitPerCameraResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecorderReinitPerCameraResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecorderReinitPerCameraResult& from) {
    RecorderReinitPerCameraResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecorderReinitPerCameraResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RecorderReinitPerCameraResult";
  }
  protected:
  explicit RecorderReinitPerCameraResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraNameFieldNumber = 1,
    kMessageFieldNumber = 3,
    kOkFieldNumber = 2,
  };
  // string camera_name = 1;
  void clear_camera_name();
  const std::string& camera_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camera_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camera_name();
  PROTOBUF_NODISCARD std::string* release_camera_name();
  void set_allocated_camera_name(std::string* camera_name);
  private:
  const std::string& _internal_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camera_name(const std::string& value);
  std::string* _internal_mutable_camera_name();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool ok = 2;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:robot.RecorderReinitPerCameraResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camera_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RecorderReinitReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RecorderReinitReply) */ {
 public:
  inline RecorderReinitReply() : RecorderReinitReply(nullptr) {}
  ~RecorderReinitReply() override;
  explicit PROTOBUF_CONSTEXPR RecorderReinitReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecorderReinitReply(const RecorderReinitReply& from);
  RecorderReinitReply(RecorderReinitReply&& from) noexcept
    : RecorderReinitReply() {
    *this = ::std::move(from);
  }

  inline RecorderReinitReply& operator=(const RecorderReinitReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecorderReinitReply& operator=(RecorderReinitReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecorderReinitReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecorderReinitReply* internal_default_instance() {
    return reinterpret_cast<const RecorderReinitReply*>(
               &_RecorderReinitReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RecorderReinitReply& a, RecorderReinitReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RecorderReinitReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecorderReinitReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecorderReinitReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecorderReinitReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecorderReinitReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecorderReinitReply& from) {
    RecorderReinitReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecorderReinitReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RecorderReinitReply";
  }
  protected:
  explicit RecorderReinitReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated .robot.RecorderReinitPerCameraResult results = 3;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::robot::RecorderReinitPerCameraResult* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitPerCameraResult >*
      mutable_results();
  private:
  const ::robot::RecorderReinitPerCameraResult& _internal_results(int index) const;
  ::robot::RecorderReinitPerCameraResult* _internal_add_results();
  public:
  const ::robot::RecorderReinitPerCameraResult& results(int index) const;
  ::robot::RecorderReinitPerCameraResult* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitPerCameraResult >&
      results() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:robot.RecorderReinitReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitPerCameraResult > results_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RecorderGetStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RecorderGetStateRequest) */ {
 public:
  inline RecorderGetStateRequest() : RecorderGetStateRequest(nullptr) {}
  ~RecorderGetStateRequest() override;
  explicit PROTOBUF_CONSTEXPR RecorderGetStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecorderGetStateRequest(const RecorderGetStateRequest& from);
  RecorderGetStateRequest(RecorderGetStateRequest&& from) noexcept
    : RecorderGetStateRequest() {
    *this = ::std::move(from);
  }

  inline RecorderGetStateRequest& operator=(const RecorderGetStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecorderGetStateRequest& operator=(RecorderGetStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecorderGetStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecorderGetStateRequest* internal_default_instance() {
    return reinterpret_cast<const RecorderGetStateRequest*>(
               &_RecorderGetStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RecorderGetStateRequest& a, RecorderGetStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecorderGetStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecorderGetStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecorderGetStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecorderGetStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecorderGetStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecorderGetStateRequest& from) {
    RecorderGetStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecorderGetStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RecorderGetStateRequest";
  }
  protected:
  explicit RecorderGetStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraNamesFieldNumber = 1,
  };
  // repeated string camera_names = 1;
  int camera_names_size() const;
  private:
  int _internal_camera_names_size() const;
  public:
  void clear_camera_names();
  const std::string& camera_names(int index) const;
  std::string* mutable_camera_names(int index);
  void set_camera_names(int index, const std::string& value);
  void set_camera_names(int index, std::string&& value);
  void set_camera_names(int index, const char* value);
  void set_camera_names(int index, const char* value, size_t size);
  std::string* add_camera_names();
  void add_camera_names(const std::string& value);
  void add_camera_names(std::string&& value);
  void add_camera_names(const char* value);
  void add_camera_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& camera_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_camera_names();
  private:
  const std::string& _internal_camera_names(int index) const;
  std::string* _internal_add_camera_names();
  public:

  // @@protoc_insertion_point(class_scope:robot.RecorderGetStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> camera_names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RecorderConfigActual final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RecorderConfigActual) */ {
 public:
  inline RecorderConfigActual() : RecorderConfigActual(nullptr) {}
  ~RecorderConfigActual() override;
  explicit PROTOBUF_CONSTEXPR RecorderConfigActual(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecorderConfigActual(const RecorderConfigActual& from);
  RecorderConfigActual(RecorderConfigActual&& from) noexcept
    : RecorderConfigActual() {
    *this = ::std::move(from);
  }

  inline RecorderConfigActual& operator=(const RecorderConfigActual& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecorderConfigActual& operator=(RecorderConfigActual&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecorderConfigActual& default_instance() {
    return *internal_default_instance();
  }
  enum DetailCase {
    kRs = 1,
    kV4L2 = 2,
    DETAIL_NOT_SET = 0,
  };

  static inline const RecorderConfigActual* internal_default_instance() {
    return reinterpret_cast<const RecorderConfigActual*>(
               &_RecorderConfigActual_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RecorderConfigActual& a, RecorderConfigActual& b) {
    a.Swap(&b);
  }
  inline void Swap(RecorderConfigActual* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecorderConfigActual* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecorderConfigActual* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecorderConfigActual>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecorderConfigActual& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecorderConfigActual& from) {
    RecorderConfigActual::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecorderConfigActual* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RecorderConfigActual";
  }
  protected:
  explicit RecorderConfigActual(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRsFieldNumber = 1,
    kV4L2FieldNumber = 2,
  };
  // .robot.RsRecorderTarget rs = 1;
  bool has_rs() const;
  private:
  bool _internal_has_rs() const;
  public:
  void clear_rs();
  const ::robot::RsRecorderTarget& rs() const;
  PROTOBUF_NODISCARD ::robot::RsRecorderTarget* release_rs();
  ::robot::RsRecorderTarget* mutable_rs();
  void set_allocated_rs(::robot::RsRecorderTarget* rs);
  private:
  const ::robot::RsRecorderTarget& _internal_rs() const;
  ::robot::RsRecorderTarget* _internal_mutable_rs();
  public:
  void unsafe_arena_set_allocated_rs(
      ::robot::RsRecorderTarget* rs);
  ::robot::RsRecorderTarget* unsafe_arena_release_rs();

  // .robot.V4L2RecorderTarget v4l2 = 2;
  bool has_v4l2() const;
  private:
  bool _internal_has_v4l2() const;
  public:
  void clear_v4l2();
  const ::robot::V4L2RecorderTarget& v4l2() const;
  PROTOBUF_NODISCARD ::robot::V4L2RecorderTarget* release_v4l2();
  ::robot::V4L2RecorderTarget* mutable_v4l2();
  void set_allocated_v4l2(::robot::V4L2RecorderTarget* v4l2);
  private:
  const ::robot::V4L2RecorderTarget& _internal_v4l2() const;
  ::robot::V4L2RecorderTarget* _internal_mutable_v4l2();
  public:
  void unsafe_arena_set_allocated_v4l2(
      ::robot::V4L2RecorderTarget* v4l2);
  ::robot::V4L2RecorderTarget* unsafe_arena_release_v4l2();

  void clear_detail();
  DetailCase detail_case() const;
  // @@protoc_insertion_point(class_scope:robot.RecorderConfigActual)
 private:
  class _Internal;
  void set_has_rs();
  void set_has_v4l2();

  inline bool has_detail() const;
  inline void clear_has_detail();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DetailUnion {
      constexpr DetailUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::robot::RsRecorderTarget* rs_;
      ::robot::V4L2RecorderTarget* v4l2_;
    } detail_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RecorderGetStateReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RecorderGetStateReply) */ {
 public:
  inline RecorderGetStateReply() : RecorderGetStateReply(nullptr) {}
  ~RecorderGetStateReply() override;
  explicit PROTOBUF_CONSTEXPR RecorderGetStateReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecorderGetStateReply(const RecorderGetStateReply& from);
  RecorderGetStateReply(RecorderGetStateReply&& from) noexcept
    : RecorderGetStateReply() {
    *this = ::std::move(from);
  }

  inline RecorderGetStateReply& operator=(const RecorderGetStateReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecorderGetStateReply& operator=(RecorderGetStateReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecorderGetStateReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecorderGetStateReply* internal_default_instance() {
    return reinterpret_cast<const RecorderGetStateReply*>(
               &_RecorderGetStateReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RecorderGetStateReply& a, RecorderGetStateReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RecorderGetStateReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecorderGetStateReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecorderGetStateReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecorderGetStateReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecorderGetStateReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecorderGetStateReply& from) {
    RecorderGetStateReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecorderGetStateReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RecorderGetStateReply";
  }
  protected:
  explicit RecorderGetStateReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActualsFieldNumber = 3,
    kMessageFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated .robot.RecorderConfigActual actuals = 3;
  int actuals_size() const;
  private:
  int _internal_actuals_size() const;
  public:
  void clear_actuals();
  ::robot::RecorderConfigActual* mutable_actuals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderConfigActual >*
      mutable_actuals();
  private:
  const ::robot::RecorderConfigActual& _internal_actuals(int index) const;
  ::robot::RecorderConfigActual* _internal_add_actuals();
  public:
  const ::robot::RecorderConfigActual& actuals(int index) const;
  ::robot::RecorderConfigActual* add_actuals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderConfigActual >&
      actuals() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:robot.RecorderGetStateReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderConfigActual > actuals_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ControlSignalRequest

// .robot.ControlSignalRequest.ActionType action = 1;
inline void ControlSignalRequest::clear_action() {
  _impl_.action_ = 0;
}
inline ::robot::ControlSignalRequest_ActionType ControlSignalRequest::_internal_action() const {
  return static_cast< ::robot::ControlSignalRequest_ActionType >(_impl_.action_);
}
inline ::robot::ControlSignalRequest_ActionType ControlSignalRequest::action() const {
  // @@protoc_insertion_point(field_get:robot.ControlSignalRequest.action)
  return _internal_action();
}
inline void ControlSignalRequest::_internal_set_action(::robot::ControlSignalRequest_ActionType value) {
  
  _impl_.action_ = value;
}
inline void ControlSignalRequest::set_action(::robot::ControlSignalRequest_ActionType value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:robot.ControlSignalRequest.action)
}

// string sdp_type = 2;
inline void ControlSignalRequest::clear_sdp_type() {
  _impl_.sdp_type_.ClearToEmpty();
}
inline const std::string& ControlSignalRequest::sdp_type() const {
  // @@protoc_insertion_point(field_get:robot.ControlSignalRequest.sdp_type)
  return _internal_sdp_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlSignalRequest::set_sdp_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.ControlSignalRequest.sdp_type)
}
inline std::string* ControlSignalRequest::mutable_sdp_type() {
  std::string* _s = _internal_mutable_sdp_type();
  // @@protoc_insertion_point(field_mutable:robot.ControlSignalRequest.sdp_type)
  return _s;
}
inline const std::string& ControlSignalRequest::_internal_sdp_type() const {
  return _impl_.sdp_type_.Get();
}
inline void ControlSignalRequest::_internal_set_sdp_type(const std::string& value) {
  
  _impl_.sdp_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ControlSignalRequest::_internal_mutable_sdp_type() {
  
  return _impl_.sdp_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ControlSignalRequest::release_sdp_type() {
  // @@protoc_insertion_point(field_release:robot.ControlSignalRequest.sdp_type)
  return _impl_.sdp_type_.Release();
}
inline void ControlSignalRequest::set_allocated_sdp_type(std::string* sdp_type) {
  if (sdp_type != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_type_.SetAllocated(sdp_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_type_.IsDefault()) {
    _impl_.sdp_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.ControlSignalRequest.sdp_type)
}

// string sdp = 3;
inline void ControlSignalRequest::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& ControlSignalRequest::sdp() const {
  // @@protoc_insertion_point(field_get:robot.ControlSignalRequest.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlSignalRequest::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.ControlSignalRequest.sdp)
}
inline std::string* ControlSignalRequest::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:robot.ControlSignalRequest.sdp)
  return _s;
}
inline const std::string& ControlSignalRequest::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void ControlSignalRequest::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* ControlSignalRequest::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* ControlSignalRequest::release_sdp() {
  // @@protoc_insertion_point(field_release:robot.ControlSignalRequest.sdp)
  return _impl_.sdp_.Release();
}
inline void ControlSignalRequest::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.ControlSignalRequest.sdp)
}

// -------------------------------------------------------------------

// ControlSignalResponse

// string status = 1;
inline void ControlSignalResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ControlSignalResponse::status() const {
  // @@protoc_insertion_point(field_get:robot.ControlSignalResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlSignalResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.ControlSignalResponse.status)
}
inline std::string* ControlSignalResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:robot.ControlSignalResponse.status)
  return _s;
}
inline const std::string& ControlSignalResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void ControlSignalResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* ControlSignalResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* ControlSignalResponse::release_status() {
  // @@protoc_insertion_point(field_release:robot.ControlSignalResponse.status)
  return _impl_.status_.Release();
}
inline void ControlSignalResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.ControlSignalResponse.status)
}

// string sdp_type = 2;
inline void ControlSignalResponse::clear_sdp_type() {
  _impl_.sdp_type_.ClearToEmpty();
}
inline const std::string& ControlSignalResponse::sdp_type() const {
  // @@protoc_insertion_point(field_get:robot.ControlSignalResponse.sdp_type)
  return _internal_sdp_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlSignalResponse::set_sdp_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.ControlSignalResponse.sdp_type)
}
inline std::string* ControlSignalResponse::mutable_sdp_type() {
  std::string* _s = _internal_mutable_sdp_type();
  // @@protoc_insertion_point(field_mutable:robot.ControlSignalResponse.sdp_type)
  return _s;
}
inline const std::string& ControlSignalResponse::_internal_sdp_type() const {
  return _impl_.sdp_type_.Get();
}
inline void ControlSignalResponse::_internal_set_sdp_type(const std::string& value) {
  
  _impl_.sdp_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ControlSignalResponse::_internal_mutable_sdp_type() {
  
  return _impl_.sdp_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ControlSignalResponse::release_sdp_type() {
  // @@protoc_insertion_point(field_release:robot.ControlSignalResponse.sdp_type)
  return _impl_.sdp_type_.Release();
}
inline void ControlSignalResponse::set_allocated_sdp_type(std::string* sdp_type) {
  if (sdp_type != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_type_.SetAllocated(sdp_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_type_.IsDefault()) {
    _impl_.sdp_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.ControlSignalResponse.sdp_type)
}

// string sdp = 3;
inline void ControlSignalResponse::clear_sdp() {
  _impl_.sdp_.ClearToEmpty();
}
inline const std::string& ControlSignalResponse::sdp() const {
  // @@protoc_insertion_point(field_get:robot.ControlSignalResponse.sdp)
  return _internal_sdp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlSignalResponse::set_sdp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.ControlSignalResponse.sdp)
}
inline std::string* ControlSignalResponse::mutable_sdp() {
  std::string* _s = _internal_mutable_sdp();
  // @@protoc_insertion_point(field_mutable:robot.ControlSignalResponse.sdp)
  return _s;
}
inline const std::string& ControlSignalResponse::_internal_sdp() const {
  return _impl_.sdp_.Get();
}
inline void ControlSignalResponse::_internal_set_sdp(const std::string& value) {
  
  _impl_.sdp_.Set(value, GetArenaForAllocation());
}
inline std::string* ControlSignalResponse::_internal_mutable_sdp() {
  
  return _impl_.sdp_.Mutable(GetArenaForAllocation());
}
inline std::string* ControlSignalResponse::release_sdp() {
  // @@protoc_insertion_point(field_release:robot.ControlSignalResponse.sdp)
  return _impl_.sdp_.Release();
}
inline void ControlSignalResponse::set_allocated_sdp(std::string* sdp) {
  if (sdp != nullptr) {
    
  } else {
    
  }
  _impl_.sdp_.SetAllocated(sdp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdp_.IsDefault()) {
    _impl_.sdp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.ControlSignalResponse.sdp)
}

// -------------------------------------------------------------------

// RsStreamSpec

// string type = 1;
inline void RsStreamSpec::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& RsStreamSpec::type() const {
  // @@protoc_insertion_point(field_get:robot.RsStreamSpec.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsStreamSpec::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.RsStreamSpec.type)
}
inline std::string* RsStreamSpec::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:robot.RsStreamSpec.type)
  return _s;
}
inline const std::string& RsStreamSpec::_internal_type() const {
  return _impl_.type_.Get();
}
inline void RsStreamSpec::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* RsStreamSpec::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* RsStreamSpec::release_type() {
  // @@protoc_insertion_point(field_release:robot.RsStreamSpec.type)
  return _impl_.type_.Release();
}
inline void RsStreamSpec::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.RsStreamSpec.type)
}

// uint32 width = 2;
inline void RsStreamSpec::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t RsStreamSpec::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t RsStreamSpec::width() const {
  // @@protoc_insertion_point(field_get:robot.RsStreamSpec.width)
  return _internal_width();
}
inline void RsStreamSpec::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void RsStreamSpec::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:robot.RsStreamSpec.width)
}

// uint32 height = 3;
inline void RsStreamSpec::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t RsStreamSpec::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t RsStreamSpec::height() const {
  // @@protoc_insertion_point(field_get:robot.RsStreamSpec.height)
  return _internal_height();
}
inline void RsStreamSpec::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void RsStreamSpec::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:robot.RsStreamSpec.height)
}

// uint32 fps = 4;
inline void RsStreamSpec::clear_fps() {
  _impl_.fps_ = 0u;
}
inline uint32_t RsStreamSpec::_internal_fps() const {
  return _impl_.fps_;
}
inline uint32_t RsStreamSpec::fps() const {
  // @@protoc_insertion_point(field_get:robot.RsStreamSpec.fps)
  return _internal_fps();
}
inline void RsStreamSpec::_internal_set_fps(uint32_t value) {
  
  _impl_.fps_ = value;
}
inline void RsStreamSpec::set_fps(uint32_t value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:robot.RsStreamSpec.fps)
}

// string fmt = 5;
inline void RsStreamSpec::clear_fmt() {
  _impl_.fmt_.ClearToEmpty();
}
inline const std::string& RsStreamSpec::fmt() const {
  // @@protoc_insertion_point(field_get:robot.RsStreamSpec.fmt)
  return _internal_fmt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsStreamSpec::set_fmt(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fmt_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.RsStreamSpec.fmt)
}
inline std::string* RsStreamSpec::mutable_fmt() {
  std::string* _s = _internal_mutable_fmt();
  // @@protoc_insertion_point(field_mutable:robot.RsStreamSpec.fmt)
  return _s;
}
inline const std::string& RsStreamSpec::_internal_fmt() const {
  return _impl_.fmt_.Get();
}
inline void RsStreamSpec::_internal_set_fmt(const std::string& value) {
  
  _impl_.fmt_.Set(value, GetArenaForAllocation());
}
inline std::string* RsStreamSpec::_internal_mutable_fmt() {
  
  return _impl_.fmt_.Mutable(GetArenaForAllocation());
}
inline std::string* RsStreamSpec::release_fmt() {
  // @@protoc_insertion_point(field_release:robot.RsStreamSpec.fmt)
  return _impl_.fmt_.Release();
}
inline void RsStreamSpec::set_allocated_fmt(std::string* fmt) {
  if (fmt != nullptr) {
    
  } else {
    
  }
  _impl_.fmt_.SetAllocated(fmt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fmt_.IsDefault()) {
    _impl_.fmt_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.RsStreamSpec.fmt)
}

// -------------------------------------------------------------------

// RsRecorderTarget

// string camera_name = 1;
inline void RsRecorderTarget::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& RsRecorderTarget::camera_name() const {
  // @@protoc_insertion_point(field_get:robot.RsRecorderTarget.camera_name)
  return _internal_camera_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RsRecorderTarget::set_camera_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.camera_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.RsRecorderTarget.camera_name)
}
inline std::string* RsRecorderTarget::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:robot.RsRecorderTarget.camera_name)
  return _s;
}
inline const std::string& RsRecorderTarget::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void RsRecorderTarget::_internal_set_camera_name(const std::string& value) {
  
  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RsRecorderTarget::_internal_mutable_camera_name() {
  
  return _impl_.camera_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RsRecorderTarget::release_camera_name() {
  // @@protoc_insertion_point(field_release:robot.RsRecorderTarget.camera_name)
  return _impl_.camera_name_.Release();
}
inline void RsRecorderTarget::set_allocated_camera_name(std::string* camera_name) {
  if (camera_name != nullptr) {
    
  } else {
    
  }
  _impl_.camera_name_.SetAllocated(camera_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.camera_name_.IsDefault()) {
    _impl_.camera_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.RsRecorderTarget.camera_name)
}

// repeated .robot.RsStreamSpec streams = 2;
inline int RsRecorderTarget::_internal_streams_size() const {
  return _impl_.streams_.size();
}
inline int RsRecorderTarget::streams_size() const {
  return _internal_streams_size();
}
inline void RsRecorderTarget::clear_streams() {
  _impl_.streams_.Clear();
}
inline ::robot::RsStreamSpec* RsRecorderTarget::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:robot.RsRecorderTarget.streams)
  return _impl_.streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RsStreamSpec >*
RsRecorderTarget::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:robot.RsRecorderTarget.streams)
  return &_impl_.streams_;
}
inline const ::robot::RsStreamSpec& RsRecorderTarget::_internal_streams(int index) const {
  return _impl_.streams_.Get(index);
}
inline const ::robot::RsStreamSpec& RsRecorderTarget::streams(int index) const {
  // @@protoc_insertion_point(field_get:robot.RsRecorderTarget.streams)
  return _internal_streams(index);
}
inline ::robot::RsStreamSpec* RsRecorderTarget::_internal_add_streams() {
  return _impl_.streams_.Add();
}
inline ::robot::RsStreamSpec* RsRecorderTarget::add_streams() {
  ::robot::RsStreamSpec* _add = _internal_add_streams();
  // @@protoc_insertion_point(field_add:robot.RsRecorderTarget.streams)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RsStreamSpec >&
RsRecorderTarget::streams() const {
  // @@protoc_insertion_point(field_list:robot.RsRecorderTarget.streams)
  return _impl_.streams_;
}

// -------------------------------------------------------------------

// V4L2StreamSpec

// uint32 width = 1;
inline void V4L2StreamSpec::clear_width() {
  _impl_.width_ = 0u;
}
inline uint32_t V4L2StreamSpec::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t V4L2StreamSpec::width() const {
  // @@protoc_insertion_point(field_get:robot.V4L2StreamSpec.width)
  return _internal_width();
}
inline void V4L2StreamSpec::_internal_set_width(uint32_t value) {
  
  _impl_.width_ = value;
}
inline void V4L2StreamSpec::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:robot.V4L2StreamSpec.width)
}

// uint32 height = 2;
inline void V4L2StreamSpec::clear_height() {
  _impl_.height_ = 0u;
}
inline uint32_t V4L2StreamSpec::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t V4L2StreamSpec::height() const {
  // @@protoc_insertion_point(field_get:robot.V4L2StreamSpec.height)
  return _internal_height();
}
inline void V4L2StreamSpec::_internal_set_height(uint32_t value) {
  
  _impl_.height_ = value;
}
inline void V4L2StreamSpec::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:robot.V4L2StreamSpec.height)
}

// uint32 fps = 3;
inline void V4L2StreamSpec::clear_fps() {
  _impl_.fps_ = 0u;
}
inline uint32_t V4L2StreamSpec::_internal_fps() const {
  return _impl_.fps_;
}
inline uint32_t V4L2StreamSpec::fps() const {
  // @@protoc_insertion_point(field_get:robot.V4L2StreamSpec.fps)
  return _internal_fps();
}
inline void V4L2StreamSpec::_internal_set_fps(uint32_t value) {
  
  _impl_.fps_ = value;
}
inline void V4L2StreamSpec::set_fps(uint32_t value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:robot.V4L2StreamSpec.fps)
}

// string pixel_format_fourcc = 4;
inline void V4L2StreamSpec::clear_pixel_format_fourcc() {
  _impl_.pixel_format_fourcc_.ClearToEmpty();
}
inline const std::string& V4L2StreamSpec::pixel_format_fourcc() const {
  // @@protoc_insertion_point(field_get:robot.V4L2StreamSpec.pixel_format_fourcc)
  return _internal_pixel_format_fourcc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void V4L2StreamSpec::set_pixel_format_fourcc(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pixel_format_fourcc_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.V4L2StreamSpec.pixel_format_fourcc)
}
inline std::string* V4L2StreamSpec::mutable_pixel_format_fourcc() {
  std::string* _s = _internal_mutable_pixel_format_fourcc();
  // @@protoc_insertion_point(field_mutable:robot.V4L2StreamSpec.pixel_format_fourcc)
  return _s;
}
inline const std::string& V4L2StreamSpec::_internal_pixel_format_fourcc() const {
  return _impl_.pixel_format_fourcc_.Get();
}
inline void V4L2StreamSpec::_internal_set_pixel_format_fourcc(const std::string& value) {
  
  _impl_.pixel_format_fourcc_.Set(value, GetArenaForAllocation());
}
inline std::string* V4L2StreamSpec::_internal_mutable_pixel_format_fourcc() {
  
  return _impl_.pixel_format_fourcc_.Mutable(GetArenaForAllocation());
}
inline std::string* V4L2StreamSpec::release_pixel_format_fourcc() {
  // @@protoc_insertion_point(field_release:robot.V4L2StreamSpec.pixel_format_fourcc)
  return _impl_.pixel_format_fourcc_.Release();
}
inline void V4L2StreamSpec::set_allocated_pixel_format_fourcc(std::string* pixel_format_fourcc) {
  if (pixel_format_fourcc != nullptr) {
    
  } else {
    
  }
  _impl_.pixel_format_fourcc_.SetAllocated(pixel_format_fourcc, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pixel_format_fourcc_.IsDefault()) {
    _impl_.pixel_format_fourcc_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.V4L2StreamSpec.pixel_format_fourcc)
}

// -------------------------------------------------------------------

// V4L2RecorderTarget

// string camera_name = 1;
inline void V4L2RecorderTarget::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& V4L2RecorderTarget::camera_name() const {
  // @@protoc_insertion_point(field_get:robot.V4L2RecorderTarget.camera_name)
  return _internal_camera_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void V4L2RecorderTarget::set_camera_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.camera_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.V4L2RecorderTarget.camera_name)
}
inline std::string* V4L2RecorderTarget::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:robot.V4L2RecorderTarget.camera_name)
  return _s;
}
inline const std::string& V4L2RecorderTarget::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void V4L2RecorderTarget::_internal_set_camera_name(const std::string& value) {
  
  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* V4L2RecorderTarget::_internal_mutable_camera_name() {
  
  return _impl_.camera_name_.Mutable(GetArenaForAllocation());
}
inline std::string* V4L2RecorderTarget::release_camera_name() {
  // @@protoc_insertion_point(field_release:robot.V4L2RecorderTarget.camera_name)
  return _impl_.camera_name_.Release();
}
inline void V4L2RecorderTarget::set_allocated_camera_name(std::string* camera_name) {
  if (camera_name != nullptr) {
    
  } else {
    
  }
  _impl_.camera_name_.SetAllocated(camera_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.camera_name_.IsDefault()) {
    _impl_.camera_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.V4L2RecorderTarget.camera_name)
}

// .robot.V4L2StreamSpec stream = 2;
inline bool V4L2RecorderTarget::_internal_has_stream() const {
  return this != internal_default_instance() && _impl_.stream_ != nullptr;
}
inline bool V4L2RecorderTarget::has_stream() const {
  return _internal_has_stream();
}
inline void V4L2RecorderTarget::clear_stream() {
  if (GetArenaForAllocation() == nullptr && _impl_.stream_ != nullptr) {
    delete _impl_.stream_;
  }
  _impl_.stream_ = nullptr;
}
inline const ::robot::V4L2StreamSpec& V4L2RecorderTarget::_internal_stream() const {
  const ::robot::V4L2StreamSpec* p = _impl_.stream_;
  return p != nullptr ? *p : reinterpret_cast<const ::robot::V4L2StreamSpec&>(
      ::robot::_V4L2StreamSpec_default_instance_);
}
inline const ::robot::V4L2StreamSpec& V4L2RecorderTarget::stream() const {
  // @@protoc_insertion_point(field_get:robot.V4L2RecorderTarget.stream)
  return _internal_stream();
}
inline void V4L2RecorderTarget::unsafe_arena_set_allocated_stream(
    ::robot::V4L2StreamSpec* stream) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
  }
  _impl_.stream_ = stream;
  if (stream) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.V4L2RecorderTarget.stream)
}
inline ::robot::V4L2StreamSpec* V4L2RecorderTarget::release_stream() {
  
  ::robot::V4L2StreamSpec* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::robot::V4L2StreamSpec* V4L2RecorderTarget::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_release:robot.V4L2RecorderTarget.stream)
  
  ::robot::V4L2StreamSpec* temp = _impl_.stream_;
  _impl_.stream_ = nullptr;
  return temp;
}
inline ::robot::V4L2StreamSpec* V4L2RecorderTarget::_internal_mutable_stream() {
  
  if (_impl_.stream_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::V4L2StreamSpec>(GetArenaForAllocation());
    _impl_.stream_ = p;
  }
  return _impl_.stream_;
}
inline ::robot::V4L2StreamSpec* V4L2RecorderTarget::mutable_stream() {
  ::robot::V4L2StreamSpec* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:robot.V4L2RecorderTarget.stream)
  return _msg;
}
inline void V4L2RecorderTarget::set_allocated_stream(::robot::V4L2StreamSpec* stream) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stream_;
  }
  if (stream) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stream);
    if (message_arena != submessage_arena) {
      stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.stream_ = stream;
  // @@protoc_insertion_point(field_set_allocated:robot.V4L2RecorderTarget.stream)
}

// -------------------------------------------------------------------

// RecorderReinitTarget

// .robot.RsRecorderTarget rs = 1;
inline bool RecorderReinitTarget::_internal_has_rs() const {
  return detail_case() == kRs;
}
inline bool RecorderReinitTarget::has_rs() const {
  return _internal_has_rs();
}
inline void RecorderReinitTarget::set_has_rs() {
  _impl_._oneof_case_[0] = kRs;
}
inline void RecorderReinitTarget::clear_rs() {
  if (_internal_has_rs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.detail_.rs_;
    }
    clear_has_detail();
  }
}
inline ::robot::RsRecorderTarget* RecorderReinitTarget::release_rs() {
  // @@protoc_insertion_point(field_release:robot.RecorderReinitTarget.rs)
  if (_internal_has_rs()) {
    clear_has_detail();
    ::robot::RsRecorderTarget* temp = _impl_.detail_.rs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.detail_.rs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::RsRecorderTarget& RecorderReinitTarget::_internal_rs() const {
  return _internal_has_rs()
      ? *_impl_.detail_.rs_
      : reinterpret_cast< ::robot::RsRecorderTarget&>(::robot::_RsRecorderTarget_default_instance_);
}
inline const ::robot::RsRecorderTarget& RecorderReinitTarget::rs() const {
  // @@protoc_insertion_point(field_get:robot.RecorderReinitTarget.rs)
  return _internal_rs();
}
inline ::robot::RsRecorderTarget* RecorderReinitTarget::unsafe_arena_release_rs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.RecorderReinitTarget.rs)
  if (_internal_has_rs()) {
    clear_has_detail();
    ::robot::RsRecorderTarget* temp = _impl_.detail_.rs_;
    _impl_.detail_.rs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RecorderReinitTarget::unsafe_arena_set_allocated_rs(::robot::RsRecorderTarget* rs) {
  clear_detail();
  if (rs) {
    set_has_rs();
    _impl_.detail_.rs_ = rs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.RecorderReinitTarget.rs)
}
inline ::robot::RsRecorderTarget* RecorderReinitTarget::_internal_mutable_rs() {
  if (!_internal_has_rs()) {
    clear_detail();
    set_has_rs();
    _impl_.detail_.rs_ = CreateMaybeMessage< ::robot::RsRecorderTarget >(GetArenaForAllocation());
  }
  return _impl_.detail_.rs_;
}
inline ::robot::RsRecorderTarget* RecorderReinitTarget::mutable_rs() {
  ::robot::RsRecorderTarget* _msg = _internal_mutable_rs();
  // @@protoc_insertion_point(field_mutable:robot.RecorderReinitTarget.rs)
  return _msg;
}

// .robot.V4L2RecorderTarget v4l2 = 2;
inline bool RecorderReinitTarget::_internal_has_v4l2() const {
  return detail_case() == kV4L2;
}
inline bool RecorderReinitTarget::has_v4l2() const {
  return _internal_has_v4l2();
}
inline void RecorderReinitTarget::set_has_v4l2() {
  _impl_._oneof_case_[0] = kV4L2;
}
inline void RecorderReinitTarget::clear_v4l2() {
  if (_internal_has_v4l2()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.detail_.v4l2_;
    }
    clear_has_detail();
  }
}
inline ::robot::V4L2RecorderTarget* RecorderReinitTarget::release_v4l2() {
  // @@protoc_insertion_point(field_release:robot.RecorderReinitTarget.v4l2)
  if (_internal_has_v4l2()) {
    clear_has_detail();
    ::robot::V4L2RecorderTarget* temp = _impl_.detail_.v4l2_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.detail_.v4l2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::V4L2RecorderTarget& RecorderReinitTarget::_internal_v4l2() const {
  return _internal_has_v4l2()
      ? *_impl_.detail_.v4l2_
      : reinterpret_cast< ::robot::V4L2RecorderTarget&>(::robot::_V4L2RecorderTarget_default_instance_);
}
inline const ::robot::V4L2RecorderTarget& RecorderReinitTarget::v4l2() const {
  // @@protoc_insertion_point(field_get:robot.RecorderReinitTarget.v4l2)
  return _internal_v4l2();
}
inline ::robot::V4L2RecorderTarget* RecorderReinitTarget::unsafe_arena_release_v4l2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.RecorderReinitTarget.v4l2)
  if (_internal_has_v4l2()) {
    clear_has_detail();
    ::robot::V4L2RecorderTarget* temp = _impl_.detail_.v4l2_;
    _impl_.detail_.v4l2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RecorderReinitTarget::unsafe_arena_set_allocated_v4l2(::robot::V4L2RecorderTarget* v4l2) {
  clear_detail();
  if (v4l2) {
    set_has_v4l2();
    _impl_.detail_.v4l2_ = v4l2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.RecorderReinitTarget.v4l2)
}
inline ::robot::V4L2RecorderTarget* RecorderReinitTarget::_internal_mutable_v4l2() {
  if (!_internal_has_v4l2()) {
    clear_detail();
    set_has_v4l2();
    _impl_.detail_.v4l2_ = CreateMaybeMessage< ::robot::V4L2RecorderTarget >(GetArenaForAllocation());
  }
  return _impl_.detail_.v4l2_;
}
inline ::robot::V4L2RecorderTarget* RecorderReinitTarget::mutable_v4l2() {
  ::robot::V4L2RecorderTarget* _msg = _internal_mutable_v4l2();
  // @@protoc_insertion_point(field_mutable:robot.RecorderReinitTarget.v4l2)
  return _msg;
}

inline bool RecorderReinitTarget::has_detail() const {
  return detail_case() != DETAIL_NOT_SET;
}
inline void RecorderReinitTarget::clear_has_detail() {
  _impl_._oneof_case_[0] = DETAIL_NOT_SET;
}
inline RecorderReinitTarget::DetailCase RecorderReinitTarget::detail_case() const {
  return RecorderReinitTarget::DetailCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RecorderReinitRequest

// repeated .robot.RecorderReinitTarget targets = 1;
inline int RecorderReinitRequest::_internal_targets_size() const {
  return _impl_.targets_.size();
}
inline int RecorderReinitRequest::targets_size() const {
  return _internal_targets_size();
}
inline void RecorderReinitRequest::clear_targets() {
  _impl_.targets_.Clear();
}
inline ::robot::RecorderReinitTarget* RecorderReinitRequest::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:robot.RecorderReinitRequest.targets)
  return _impl_.targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitTarget >*
RecorderReinitRequest::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:robot.RecorderReinitRequest.targets)
  return &_impl_.targets_;
}
inline const ::robot::RecorderReinitTarget& RecorderReinitRequest::_internal_targets(int index) const {
  return _impl_.targets_.Get(index);
}
inline const ::robot::RecorderReinitTarget& RecorderReinitRequest::targets(int index) const {
  // @@protoc_insertion_point(field_get:robot.RecorderReinitRequest.targets)
  return _internal_targets(index);
}
inline ::robot::RecorderReinitTarget* RecorderReinitRequest::_internal_add_targets() {
  return _impl_.targets_.Add();
}
inline ::robot::RecorderReinitTarget* RecorderReinitRequest::add_targets() {
  ::robot::RecorderReinitTarget* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:robot.RecorderReinitRequest.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitTarget >&
RecorderReinitRequest::targets() const {
  // @@protoc_insertion_point(field_list:robot.RecorderReinitRequest.targets)
  return _impl_.targets_;
}

// -------------------------------------------------------------------

// RecorderReinitPerCameraResult

// string camera_name = 1;
inline void RecorderReinitPerCameraResult::clear_camera_name() {
  _impl_.camera_name_.ClearToEmpty();
}
inline const std::string& RecorderReinitPerCameraResult::camera_name() const {
  // @@protoc_insertion_point(field_get:robot.RecorderReinitPerCameraResult.camera_name)
  return _internal_camera_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecorderReinitPerCameraResult::set_camera_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.camera_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.RecorderReinitPerCameraResult.camera_name)
}
inline std::string* RecorderReinitPerCameraResult::mutable_camera_name() {
  std::string* _s = _internal_mutable_camera_name();
  // @@protoc_insertion_point(field_mutable:robot.RecorderReinitPerCameraResult.camera_name)
  return _s;
}
inline const std::string& RecorderReinitPerCameraResult::_internal_camera_name() const {
  return _impl_.camera_name_.Get();
}
inline void RecorderReinitPerCameraResult::_internal_set_camera_name(const std::string& value) {
  
  _impl_.camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RecorderReinitPerCameraResult::_internal_mutable_camera_name() {
  
  return _impl_.camera_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RecorderReinitPerCameraResult::release_camera_name() {
  // @@protoc_insertion_point(field_release:robot.RecorderReinitPerCameraResult.camera_name)
  return _impl_.camera_name_.Release();
}
inline void RecorderReinitPerCameraResult::set_allocated_camera_name(std::string* camera_name) {
  if (camera_name != nullptr) {
    
  } else {
    
  }
  _impl_.camera_name_.SetAllocated(camera_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.camera_name_.IsDefault()) {
    _impl_.camera_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.RecorderReinitPerCameraResult.camera_name)
}

// bool ok = 2;
inline void RecorderReinitPerCameraResult::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RecorderReinitPerCameraResult::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RecorderReinitPerCameraResult::ok() const {
  // @@protoc_insertion_point(field_get:robot.RecorderReinitPerCameraResult.ok)
  return _internal_ok();
}
inline void RecorderReinitPerCameraResult::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RecorderReinitPerCameraResult::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:robot.RecorderReinitPerCameraResult.ok)
}

// string message = 3;
inline void RecorderReinitPerCameraResult::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RecorderReinitPerCameraResult::message() const {
  // @@protoc_insertion_point(field_get:robot.RecorderReinitPerCameraResult.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecorderReinitPerCameraResult::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.RecorderReinitPerCameraResult.message)
}
inline std::string* RecorderReinitPerCameraResult::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:robot.RecorderReinitPerCameraResult.message)
  return _s;
}
inline const std::string& RecorderReinitPerCameraResult::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RecorderReinitPerCameraResult::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RecorderReinitPerCameraResult::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RecorderReinitPerCameraResult::release_message() {
  // @@protoc_insertion_point(field_release:robot.RecorderReinitPerCameraResult.message)
  return _impl_.message_.Release();
}
inline void RecorderReinitPerCameraResult::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.RecorderReinitPerCameraResult.message)
}

// -------------------------------------------------------------------

// RecorderReinitReply

// bool ok = 1;
inline void RecorderReinitReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RecorderReinitReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RecorderReinitReply::ok() const {
  // @@protoc_insertion_point(field_get:robot.RecorderReinitReply.ok)
  return _internal_ok();
}
inline void RecorderReinitReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RecorderReinitReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:robot.RecorderReinitReply.ok)
}

// string message = 2;
inline void RecorderReinitReply::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RecorderReinitReply::message() const {
  // @@protoc_insertion_point(field_get:robot.RecorderReinitReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecorderReinitReply::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.RecorderReinitReply.message)
}
inline std::string* RecorderReinitReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:robot.RecorderReinitReply.message)
  return _s;
}
inline const std::string& RecorderReinitReply::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RecorderReinitReply::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RecorderReinitReply::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RecorderReinitReply::release_message() {
  // @@protoc_insertion_point(field_release:robot.RecorderReinitReply.message)
  return _impl_.message_.Release();
}
inline void RecorderReinitReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.RecorderReinitReply.message)
}

// repeated .robot.RecorderReinitPerCameraResult results = 3;
inline int RecorderReinitReply::_internal_results_size() const {
  return _impl_.results_.size();
}
inline int RecorderReinitReply::results_size() const {
  return _internal_results_size();
}
inline void RecorderReinitReply::clear_results() {
  _impl_.results_.Clear();
}
inline ::robot::RecorderReinitPerCameraResult* RecorderReinitReply::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:robot.RecorderReinitReply.results)
  return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitPerCameraResult >*
RecorderReinitReply::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:robot.RecorderReinitReply.results)
  return &_impl_.results_;
}
inline const ::robot::RecorderReinitPerCameraResult& RecorderReinitReply::_internal_results(int index) const {
  return _impl_.results_.Get(index);
}
inline const ::robot::RecorderReinitPerCameraResult& RecorderReinitReply::results(int index) const {
  // @@protoc_insertion_point(field_get:robot.RecorderReinitReply.results)
  return _internal_results(index);
}
inline ::robot::RecorderReinitPerCameraResult* RecorderReinitReply::_internal_add_results() {
  return _impl_.results_.Add();
}
inline ::robot::RecorderReinitPerCameraResult* RecorderReinitReply::add_results() {
  ::robot::RecorderReinitPerCameraResult* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:robot.RecorderReinitReply.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderReinitPerCameraResult >&
RecorderReinitReply::results() const {
  // @@protoc_insertion_point(field_list:robot.RecorderReinitReply.results)
  return _impl_.results_;
}

// -------------------------------------------------------------------

// RecorderGetStateRequest

// repeated string camera_names = 1;
inline int RecorderGetStateRequest::_internal_camera_names_size() const {
  return _impl_.camera_names_.size();
}
inline int RecorderGetStateRequest::camera_names_size() const {
  return _internal_camera_names_size();
}
inline void RecorderGetStateRequest::clear_camera_names() {
  _impl_.camera_names_.Clear();
}
inline std::string* RecorderGetStateRequest::add_camera_names() {
  std::string* _s = _internal_add_camera_names();
  // @@protoc_insertion_point(field_add_mutable:robot.RecorderGetStateRequest.camera_names)
  return _s;
}
inline const std::string& RecorderGetStateRequest::_internal_camera_names(int index) const {
  return _impl_.camera_names_.Get(index);
}
inline const std::string& RecorderGetStateRequest::camera_names(int index) const {
  // @@protoc_insertion_point(field_get:robot.RecorderGetStateRequest.camera_names)
  return _internal_camera_names(index);
}
inline std::string* RecorderGetStateRequest::mutable_camera_names(int index) {
  // @@protoc_insertion_point(field_mutable:robot.RecorderGetStateRequest.camera_names)
  return _impl_.camera_names_.Mutable(index);
}
inline void RecorderGetStateRequest::set_camera_names(int index, const std::string& value) {
  _impl_.camera_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:robot.RecorderGetStateRequest.camera_names)
}
inline void RecorderGetStateRequest::set_camera_names(int index, std::string&& value) {
  _impl_.camera_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:robot.RecorderGetStateRequest.camera_names)
}
inline void RecorderGetStateRequest::set_camera_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.camera_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:robot.RecorderGetStateRequest.camera_names)
}
inline void RecorderGetStateRequest::set_camera_names(int index, const char* value, size_t size) {
  _impl_.camera_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:robot.RecorderGetStateRequest.camera_names)
}
inline std::string* RecorderGetStateRequest::_internal_add_camera_names() {
  return _impl_.camera_names_.Add();
}
inline void RecorderGetStateRequest::add_camera_names(const std::string& value) {
  _impl_.camera_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:robot.RecorderGetStateRequest.camera_names)
}
inline void RecorderGetStateRequest::add_camera_names(std::string&& value) {
  _impl_.camera_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:robot.RecorderGetStateRequest.camera_names)
}
inline void RecorderGetStateRequest::add_camera_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.camera_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:robot.RecorderGetStateRequest.camera_names)
}
inline void RecorderGetStateRequest::add_camera_names(const char* value, size_t size) {
  _impl_.camera_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:robot.RecorderGetStateRequest.camera_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RecorderGetStateRequest::camera_names() const {
  // @@protoc_insertion_point(field_list:robot.RecorderGetStateRequest.camera_names)
  return _impl_.camera_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RecorderGetStateRequest::mutable_camera_names() {
  // @@protoc_insertion_point(field_mutable_list:robot.RecorderGetStateRequest.camera_names)
  return &_impl_.camera_names_;
}

// -------------------------------------------------------------------

// RecorderConfigActual

// .robot.RsRecorderTarget rs = 1;
inline bool RecorderConfigActual::_internal_has_rs() const {
  return detail_case() == kRs;
}
inline bool RecorderConfigActual::has_rs() const {
  return _internal_has_rs();
}
inline void RecorderConfigActual::set_has_rs() {
  _impl_._oneof_case_[0] = kRs;
}
inline void RecorderConfigActual::clear_rs() {
  if (_internal_has_rs()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.detail_.rs_;
    }
    clear_has_detail();
  }
}
inline ::robot::RsRecorderTarget* RecorderConfigActual::release_rs() {
  // @@protoc_insertion_point(field_release:robot.RecorderConfigActual.rs)
  if (_internal_has_rs()) {
    clear_has_detail();
    ::robot::RsRecorderTarget* temp = _impl_.detail_.rs_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.detail_.rs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::RsRecorderTarget& RecorderConfigActual::_internal_rs() const {
  return _internal_has_rs()
      ? *_impl_.detail_.rs_
      : reinterpret_cast< ::robot::RsRecorderTarget&>(::robot::_RsRecorderTarget_default_instance_);
}
inline const ::robot::RsRecorderTarget& RecorderConfigActual::rs() const {
  // @@protoc_insertion_point(field_get:robot.RecorderConfigActual.rs)
  return _internal_rs();
}
inline ::robot::RsRecorderTarget* RecorderConfigActual::unsafe_arena_release_rs() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.RecorderConfigActual.rs)
  if (_internal_has_rs()) {
    clear_has_detail();
    ::robot::RsRecorderTarget* temp = _impl_.detail_.rs_;
    _impl_.detail_.rs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RecorderConfigActual::unsafe_arena_set_allocated_rs(::robot::RsRecorderTarget* rs) {
  clear_detail();
  if (rs) {
    set_has_rs();
    _impl_.detail_.rs_ = rs;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.RecorderConfigActual.rs)
}
inline ::robot::RsRecorderTarget* RecorderConfigActual::_internal_mutable_rs() {
  if (!_internal_has_rs()) {
    clear_detail();
    set_has_rs();
    _impl_.detail_.rs_ = CreateMaybeMessage< ::robot::RsRecorderTarget >(GetArenaForAllocation());
  }
  return _impl_.detail_.rs_;
}
inline ::robot::RsRecorderTarget* RecorderConfigActual::mutable_rs() {
  ::robot::RsRecorderTarget* _msg = _internal_mutable_rs();
  // @@protoc_insertion_point(field_mutable:robot.RecorderConfigActual.rs)
  return _msg;
}

// .robot.V4L2RecorderTarget v4l2 = 2;
inline bool RecorderConfigActual::_internal_has_v4l2() const {
  return detail_case() == kV4L2;
}
inline bool RecorderConfigActual::has_v4l2() const {
  return _internal_has_v4l2();
}
inline void RecorderConfigActual::set_has_v4l2() {
  _impl_._oneof_case_[0] = kV4L2;
}
inline void RecorderConfigActual::clear_v4l2() {
  if (_internal_has_v4l2()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.detail_.v4l2_;
    }
    clear_has_detail();
  }
}
inline ::robot::V4L2RecorderTarget* RecorderConfigActual::release_v4l2() {
  // @@protoc_insertion_point(field_release:robot.RecorderConfigActual.v4l2)
  if (_internal_has_v4l2()) {
    clear_has_detail();
    ::robot::V4L2RecorderTarget* temp = _impl_.detail_.v4l2_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.detail_.v4l2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::V4L2RecorderTarget& RecorderConfigActual::_internal_v4l2() const {
  return _internal_has_v4l2()
      ? *_impl_.detail_.v4l2_
      : reinterpret_cast< ::robot::V4L2RecorderTarget&>(::robot::_V4L2RecorderTarget_default_instance_);
}
inline const ::robot::V4L2RecorderTarget& RecorderConfigActual::v4l2() const {
  // @@protoc_insertion_point(field_get:robot.RecorderConfigActual.v4l2)
  return _internal_v4l2();
}
inline ::robot::V4L2RecorderTarget* RecorderConfigActual::unsafe_arena_release_v4l2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.RecorderConfigActual.v4l2)
  if (_internal_has_v4l2()) {
    clear_has_detail();
    ::robot::V4L2RecorderTarget* temp = _impl_.detail_.v4l2_;
    _impl_.detail_.v4l2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RecorderConfigActual::unsafe_arena_set_allocated_v4l2(::robot::V4L2RecorderTarget* v4l2) {
  clear_detail();
  if (v4l2) {
    set_has_v4l2();
    _impl_.detail_.v4l2_ = v4l2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.RecorderConfigActual.v4l2)
}
inline ::robot::V4L2RecorderTarget* RecorderConfigActual::_internal_mutable_v4l2() {
  if (!_internal_has_v4l2()) {
    clear_detail();
    set_has_v4l2();
    _impl_.detail_.v4l2_ = CreateMaybeMessage< ::robot::V4L2RecorderTarget >(GetArenaForAllocation());
  }
  return _impl_.detail_.v4l2_;
}
inline ::robot::V4L2RecorderTarget* RecorderConfigActual::mutable_v4l2() {
  ::robot::V4L2RecorderTarget* _msg = _internal_mutable_v4l2();
  // @@protoc_insertion_point(field_mutable:robot.RecorderConfigActual.v4l2)
  return _msg;
}

inline bool RecorderConfigActual::has_detail() const {
  return detail_case() != DETAIL_NOT_SET;
}
inline void RecorderConfigActual::clear_has_detail() {
  _impl_._oneof_case_[0] = DETAIL_NOT_SET;
}
inline RecorderConfigActual::DetailCase RecorderConfigActual::detail_case() const {
  return RecorderConfigActual::DetailCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RecorderGetStateReply

// bool ok = 1;
inline void RecorderGetStateReply::clear_ok() {
  _impl_.ok_ = false;
}
inline bool RecorderGetStateReply::_internal_ok() const {
  return _impl_.ok_;
}
inline bool RecorderGetStateReply::ok() const {
  // @@protoc_insertion_point(field_get:robot.RecorderGetStateReply.ok)
  return _internal_ok();
}
inline void RecorderGetStateReply::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void RecorderGetStateReply::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:robot.RecorderGetStateReply.ok)
}

// string message = 2;
inline void RecorderGetStateReply::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& RecorderGetStateReply::message() const {
  // @@protoc_insertion_point(field_get:robot.RecorderGetStateReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecorderGetStateReply::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:robot.RecorderGetStateReply.message)
}
inline std::string* RecorderGetStateReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:robot.RecorderGetStateReply.message)
  return _s;
}
inline const std::string& RecorderGetStateReply::_internal_message() const {
  return _impl_.message_.Get();
}
inline void RecorderGetStateReply::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* RecorderGetStateReply::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* RecorderGetStateReply::release_message() {
  // @@protoc_insertion_point(field_release:robot.RecorderGetStateReply.message)
  return _impl_.message_.Release();
}
inline void RecorderGetStateReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:robot.RecorderGetStateReply.message)
}

// repeated .robot.RecorderConfigActual actuals = 3;
inline int RecorderGetStateReply::_internal_actuals_size() const {
  return _impl_.actuals_.size();
}
inline int RecorderGetStateReply::actuals_size() const {
  return _internal_actuals_size();
}
inline void RecorderGetStateReply::clear_actuals() {
  _impl_.actuals_.Clear();
}
inline ::robot::RecorderConfigActual* RecorderGetStateReply::mutable_actuals(int index) {
  // @@protoc_insertion_point(field_mutable:robot.RecorderGetStateReply.actuals)
  return _impl_.actuals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderConfigActual >*
RecorderGetStateReply::mutable_actuals() {
  // @@protoc_insertion_point(field_mutable_list:robot.RecorderGetStateReply.actuals)
  return &_impl_.actuals_;
}
inline const ::robot::RecorderConfigActual& RecorderGetStateReply::_internal_actuals(int index) const {
  return _impl_.actuals_.Get(index);
}
inline const ::robot::RecorderConfigActual& RecorderGetStateReply::actuals(int index) const {
  // @@protoc_insertion_point(field_get:robot.RecorderGetStateReply.actuals)
  return _internal_actuals(index);
}
inline ::robot::RecorderConfigActual* RecorderGetStateReply::_internal_add_actuals() {
  return _impl_.actuals_.Add();
}
inline ::robot::RecorderConfigActual* RecorderGetStateReply::add_actuals() {
  ::robot::RecorderConfigActual* _add = _internal_add_actuals();
  // @@protoc_insertion_point(field_add:robot.RecorderGetStateReply.actuals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RecorderConfigActual >&
RecorderGetStateReply::actuals() const {
  // @@protoc_insertion_point(field_list:robot.RecorderGetStateReply.actuals)
  return _impl_.actuals_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace robot

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::robot::ControlSignalRequest_ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robot::ControlSignalRequest_ActionType>() {
  return ::robot::ControlSignalRequest_ActionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_2eproto
